import redis
import socket
from concurrent.futures import ThreadPoolExecutor
import argparse
from termcolor import colored
import concurrent.futures

def is_port_open(ip, port, timeout=0.5):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(timeout)
        try:
            s.connect((ip, port))
            return True
        except (socket.timeout, ConnectionRefusedError, OSError):
            return False

def check_redis(ip, port, timeout=2.0, poc=False):
    result = {
        "ip": ip,
        "port": port,
        "connected": False,
        "vulnerable": False,
        "info_accessible": False,
        "poc_data": None,
        "poc_command": None
    }

    try:
        with redis.Redis(host=ip, port=port, socket_connect_timeout=timeout, socket_timeout=timeout) as r:
            r.ping()
            result["connected"] = True
            try:
                info_response = r.info()
                result["info_accessible"] = True
                result["vulnerable"] = True
                if poc:
                    keys = r.keys()
                    if keys:
                        result["poc_command"] = "KEYS *"
                        result["poc_data"] = {key.decode('utf-8'): r.get(key).decode('utf-8') for key in keys[:5]}  # Fetch up to 5 keys
            except redis.exceptions.ResponseError:
                result["info_accessible"] = False
    except redis.RedisError:
        result["connected"] = False

    return result

def scan_job(ip_port_tuple, timeout=2.0, poc=False):
    ip, port = ip_port_tuple
    if is_port_open(ip, port):
        return check_redis(ip, port, timeout, poc)
    else:
        return {
            "ip": ip,
            "port": port,
            "connected": False,
            "vulnerable": False,
            "info_accessible": False,
            "reachable": False
        }

def scan_redis(ips, ports, max_workers=10, poc=False):
    results = []
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        ip_port_pairs = [(ip, port) for ip in ips for port in ports]
        future_to_ip_port = {executor.submit(scan_job, ip_port, poc=poc): ip_port for ip_port in ip_port_pairs}
        for future in concurrent.futures.as_completed(future_to_ip_port):
            ip_port = future_to_ip_port[future]
            try:
                result = future.result()
                results.append(result)
            except Exception:
                pass
    return results

def read_ips_from_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        ips = []
        for line in lines:
            ips.extend(line.strip().split(','))  # Split by comma first
        ips = [ip.strip() for ip in ips if ip.strip()]  # Remove any extra whitespace and empty strings
        return ips

def display_results(results, only_vulnerable=False, only_ips=False):
    vulnerable_count = 0
    non_vulnerable_count = 0
    not_reachable_count = 0

    for result in results:
        if result["vulnerable"]:
            vulnerable_count += 1
            if only_ips:
                print(result['ip'])
                continue
            
            ip_port = f"{result['ip']}:{result['port']}"
            status = colored("Vulnerable", "red")
            poc_command = result.get("poc_command", "No PoC command executed")
            poc_data = result.get("poc_data")
            if poc_data:
                poc_display = "\n".join([f"{k}: {v}" for k, v in poc_data.items()])
                poc_display = f"{colored('PoC Command:', 'yellow')} {poc_command}\n{colored(poc_display, 'yellow')}"
            else:
                poc_display = f"{colored('PoC Command:', 'yellow')} {poc_command}\n{colored('No data available', 'yellow')}"
            
            print(f"{ip_port} - {status}")
            if poc_display:
                print(poc_display)
                print("-" * 50)
        else:
            if result["connected"]:
                non_vulnerable_count += 1
                if not only_vulnerable:
                    ip_port = f"{result['ip']}:{result['port']}"
                    status = colored("Not Vulnerable", "green")
                    print(f"{ip_port} - {status}")
            else:
                not_reachable_count += 1
                if not only_vulnerable:
                    ip_port = f"{result['ip']}:{result['port']}"
                    status = colored("Not Reachable", "blue")
                    print(f"{ip_port} - {status}")
    
    if not only_ips:
        print(f"\nTotal Vulnerable IPs: {vulnerable_count}")
        print(f"Total Non-Vulnerable IPs: {non_vulnerable_count}")
        print(f"Total Not Reachable IPs: {not_reachable_count}")

def main():
    parser = argparse.ArgumentParser(description="Scan Redis instances on given IPs and ports.")
    parser.add_argument("--ips", nargs="+", help="List of IP addresses to scan (space/comma separated).")
    parser.add_argument("--ips-file", help="File containing IP addresses (line/space/comma separated).")
    parser.add_argument("--ports", nargs="+", type=int, required=True, help="List of ports to scan.")
    parser.add_argument("--max-workers", type=int, default=10, help="Maximum number of worker threads.")
    parser.add_argument("--poc", action="store_true", help="Fetch proof of concept data from Redis.")
    parser.add_argument("--only-vulnerable", action="store_true", help="Print only vulnerable IPs and their details.")
    parser.add_argument("--only-ips", action="store_true", help="Print only IP addresses of vulnerable instances.")
    args = parser.parse_args()

    if not args.ips and not args.ips_file:
        parser.error("At least one of --ips or --ips-file must be specified.")
    
    ips = []
    if args.ips:
        for ip in args.ips:
            ips.extend(ip.split(','))  # Split by comma if provided
        ips = [ip.strip() for ip in ips if ip.strip()]  # Remove any extra whitespace and empty strings
    if args.ips_file:
        ips.extend(read_ips_from_file(args.ips_file))
    
    ports = args.ports
    max_workers = args.max_workers
    poc = args.poc
    only_vulnerable = args.only_vulnerable
    only_ips = args.only_ips

    results = scan_redis(ips, ports, max_workers=max_workers, poc=poc)
    display_results(results, only_vulnerable, only_ips)

if __name__ == "__main__":
    print(r"""
     ____  _    _  ____  ____
    | __ )| |  | |/ ___|| __ )
    |  _ \| |  | | |  _ |  _ \
    | |_) | |__| | |_| || |_) |
    |____/ \____/ \____||____/
    https://www.bugb.report

    Author: zippon
    """)
    main()
